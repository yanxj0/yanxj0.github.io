import{T as D}from"./splaytree-2252a986.js";const C=11102230246251565e-32,I=134217729,ct=(3+8*C)*C;function Q(f,t,e,n,r){let i,h,o,u,c=t[0],g=n[0],s=0,l=0;g>c==g>-c?(i=c,c=t[++s]):(i=g,g=n[++l]);let p=0;if(s<f&&l<e)for(g>c==g>-c?(h=c+i,o=i-(h-c),c=t[++s]):(h=g+i,o=i-(h-g),g=n[++l]),i=h,o!==0&&(r[p++]=o);s<f&&l<e;)g>c==g>-c?(h=i+c,u=h-i,o=i-(h-u)+(c-u),c=t[++s]):(h=i+g,u=h-i,o=i-(h-u)+(g-u),g=n[++l]),i=h,o!==0&&(r[p++]=o);for(;s<f;)h=i+c,u=h-i,o=i-(h-u)+(c-u),c=t[++s],i=h,o!==0&&(r[p++]=o);for(;l<e;)h=i+g,u=h-i,o=i-(h-u)+(g-u),g=n[++l],i=h,o!==0&&(r[p++]=o);return(i!==0||p===0)&&(r[p++]=i),p}function ft(f,t){let e=t[0];for(let n=1;n<f;n++)e+=t[n];return e}function Y(f){return new Float64Array(f)}const pt=(3+16*C)*C,gt=(2+12*C)*C,xt=(9+64*C)*C*C,j=Y(4),V=Y(8),W=Y(12),Z=Y(16),R=Y(4);function yt(f,t,e,n,r,i,h){let o,u,c,g,s,l,p,y,x,E,a,d,S,m,w,b,P,v;const A=f-r,L=e-r,O=t-i,_=n-i;m=A*_,l=I*A,p=l-(l-A),y=A-p,l=I*_,x=l-(l-_),E=_-x,w=y*E-(m-p*x-y*x-p*E),b=O*L,l=I*O,p=l-(l-O),y=O-p,l=I*L,x=l-(l-L),E=L-x,P=y*E-(b-p*x-y*x-p*E),a=w-P,s=w-a,j[0]=w-(a+s)+(s-P),d=m+a,s=d-m,S=m-(d-s)+(a-s),a=S-b,s=S-a,j[1]=S-(a+s)+(s-b),v=d+a,s=v-d,j[2]=d-(v-s)+(a-s),j[3]=v;let B=ft(4,j),F=gt*h;if(B>=F||-B>=F||(s=f-A,o=f-(A+s)+(s-r),s=e-L,c=e-(L+s)+(s-r),s=t-O,u=t-(O+s)+(s-i),s=n-_,g=n-(_+s)+(s-i),o===0&&u===0&&c===0&&g===0)||(F=xt*h+ct*Math.abs(B),B+=A*g+_*o-(O*c+L*u),B>=F||-B>=F))return B;m=o*_,l=I*o,p=l-(l-o),y=o-p,l=I*_,x=l-(l-_),E=_-x,w=y*E-(m-p*x-y*x-p*E),b=u*L,l=I*u,p=l-(l-u),y=u-p,l=I*L,x=l-(l-L),E=L-x,P=y*E-(b-p*x-y*x-p*E),a=w-P,s=w-a,R[0]=w-(a+s)+(s-P),d=m+a,s=d-m,S=m-(d-s)+(a-s),a=S-b,s=S-a,R[1]=S-(a+s)+(s-b),v=d+a,s=v-d,R[2]=d-(v-s)+(a-s),R[3]=v;const lt=Q(4,j,4,R,V);m=A*g,l=I*A,p=l-(l-A),y=A-p,l=I*g,x=l-(l-g),E=g-x,w=y*E-(m-p*x-y*x-p*E),b=O*c,l=I*O,p=l-(l-O),y=O-p,l=I*c,x=l-(l-c),E=c-x,P=y*E-(b-p*x-y*x-p*E),a=w-P,s=w-a,R[0]=w-(a+s)+(s-P),d=m+a,s=d-m,S=m-(d-s)+(a-s),a=S-b,s=S-a,R[1]=S-(a+s)+(s-b),v=d+a,s=v-d,R[2]=d-(v-s)+(a-s),R[3]=v;const ut=Q(lt,V,4,R,W);m=o*g,l=I*o,p=l-(l-o),y=o-p,l=I*g,x=l-(l-g),E=g-x,w=y*E-(m-p*x-y*x-p*E),b=u*c,l=I*u,p=l-(l-u),y=u-p,l=I*c,x=l-(l-c),E=c-x,P=y*E-(b-p*x-y*x-p*E),a=w-P,s=w-a,R[0]=w-(a+s)+(s-P),d=m+a,s=d-m,S=m-(d-s)+(a-s),a=S-b,s=S-a,R[1]=S-(a+s)+(s-b),v=d+a,s=v-d,R[2]=d-(v-s)+(a-s),R[3]=v;const ht=Q(ut,W,4,R,Z);return Z[ht-1]}function at(f,t,e,n,r,i){const h=(t-i)*(e-r),o=(f-r)*(n-i),u=h-o,c=Math.abs(h+o);return Math.abs(u)>=pt*c?u:-yt(f,t,e,n,r,i,c)}const G=(f,t)=>f.ll.x<=t.x&&t.x<=f.ur.x&&f.ll.y<=t.y&&t.y<=f.ur.y,X=(f,t)=>{if(t.ur.x<f.ll.x||f.ur.x<t.ll.x||t.ur.y<f.ll.y||f.ur.y<t.ll.y)return null;const e=f.ll.x<t.ll.x?t.ll.x:f.ll.x,n=f.ur.x<t.ur.x?f.ur.x:t.ur.x,r=f.ll.y<t.ll.y?t.ll.y:f.ll.y,i=f.ur.y<t.ur.y?f.ur.y:t.ur.y;return{ll:{x:e,y:r},ur:{x:n,y:i}}};let $=Number.EPSILON;$===void 0&&($=Math.pow(2,-52));const Et=$*$,J=(f,t)=>{if(-$<f&&f<$&&-$<t&&t<$)return 0;const e=f-t;return e*e<Et*f*t?0:f<t?-1:1};class dt{constructor(){this.reset()}reset(){this.xRounder=new H,this.yRounder=new H}round(t,e){return{x:this.xRounder.round(t),y:this.yRounder.round(e)}}}class H{constructor(){this.tree=new D,this.round(0)}round(t){const e=this.tree.add(t),n=this.tree.prev(e);if(n!==null&&J(e.key,n.key)===0)return this.tree.remove(t),n.key;const r=this.tree.next(e);return r!==null&&J(e.key,r.key)===0?(this.tree.remove(t),r.key):t}}const T=new dt,q=(f,t)=>f.x*t.y-f.y*t.x,ot=(f,t)=>f.x*t.x+f.y*t.y,K=(f,t,e)=>{const n=at(f.x,f.y,t.x,t.y,e.x,e.y);return n>0?-1:n<0?1:0},z=f=>Math.sqrt(ot(f,f)),mt=(f,t,e)=>{const n={x:t.x-f.x,y:t.y-f.y},r={x:e.x-f.x,y:e.y-f.y};return q(r,n)/z(r)/z(n)},St=(f,t,e)=>{const n={x:t.x-f.x,y:t.y-f.y},r={x:e.x-f.x,y:e.y-f.y};return ot(r,n)/z(r)/z(n)},tt=(f,t,e)=>t.y===0?null:{x:f.x+t.x/t.y*(e-f.y),y:e},et=(f,t,e)=>t.x===0?null:{x:e,y:f.y+t.y/t.x*(e-f.x)},wt=(f,t,e,n)=>{if(t.x===0)return et(e,n,f.x);if(n.x===0)return et(f,t,e.x);if(t.y===0)return tt(e,n,f.y);if(n.y===0)return tt(f,t,e.y);const r=q(t,n);if(r==0)return null;const i={x:e.x-f.x,y:e.y-f.y},h=q(i,t)/r,o=q(i,n)/r,u=f.x+o*t.x,c=e.x+h*n.x,g=f.y+o*t.y,s=e.y+h*n.y,l=(u+c)/2,p=(g+s)/2;return{x:l,y:p}};class M{static compare(t,e){const n=M.comparePoints(t.point,e.point);return n!==0?n:(t.point!==e.point&&t.link(e),t.isLeft!==e.isLeft?t.isLeft?1:-1:k.compare(t.segment,e.segment))}static comparePoints(t,e){return t.x<e.x?-1:t.x>e.x?1:t.y<e.y?-1:t.y>e.y?1:0}constructor(t,e){t.events===void 0?t.events=[this]:t.events.push(this),this.point=t,this.isLeft=e}link(t){if(t.point===this.point)throw new Error("Tried to link already linked events");const e=t.point.events;for(let n=0,r=e.length;n<r;n++){const i=e[n];this.point.events.push(i),i.point=this.point}this.checkForConsuming()}checkForConsuming(){const t=this.point.events.length;for(let e=0;e<t;e++){const n=this.point.events[e];if(n.segment.consumedBy===void 0)for(let r=e+1;r<t;r++){const i=this.point.events[r];i.consumedBy===void 0&&n.otherSE.point.events===i.otherSE.point.events&&n.segment.consume(i.segment)}}}getAvailableLinkedEvents(){const t=[];for(let e=0,n=this.point.events.length;e<n;e++){const r=this.point.events[e];r!==this&&!r.segment.ringOut&&r.segment.isInResult()&&t.push(r)}return t}getLeftmostComparator(t){const e=new Map,n=r=>{const i=r.otherSE;e.set(r,{sine:mt(this.point,t.point,i.point),cosine:St(this.point,t.point,i.point)})};return(r,i)=>{e.has(r)||n(r),e.has(i)||n(i);const{sine:h,cosine:o}=e.get(r),{sine:u,cosine:c}=e.get(i);return h>=0&&u>=0?o<c?1:o>c?-1:0:h<0&&u<0?o<c?-1:o>c?1:0:u<h?-1:u>h?1:0}}}let bt=0;class k{static compare(t,e){const n=t.leftSE.point.x,r=e.leftSE.point.x,i=t.rightSE.point.x,h=e.rightSE.point.x;if(h<n)return 1;if(i<r)return-1;const o=t.leftSE.point.y,u=e.leftSE.point.y,c=t.rightSE.point.y,g=e.rightSE.point.y;if(n<r){if(u<o&&u<c)return 1;if(u>o&&u>c)return-1;const s=t.comparePoint(e.leftSE.point);if(s<0)return 1;if(s>0)return-1;const l=e.comparePoint(t.rightSE.point);return l!==0?l:-1}if(n>r){if(o<u&&o<g)return-1;if(o>u&&o>g)return 1;const s=e.comparePoint(t.leftSE.point);if(s!==0)return s;const l=t.comparePoint(e.rightSE.point);return l<0?1:l>0?-1:1}if(o<u)return-1;if(o>u)return 1;if(i<h){const s=e.comparePoint(t.rightSE.point);if(s!==0)return s}if(i>h){const s=t.comparePoint(e.rightSE.point);if(s<0)return 1;if(s>0)return-1}if(i!==h){const s=c-o,l=i-n,p=g-u,y=h-r;if(s>l&&p<y)return 1;if(s<l&&p>y)return-1}return i>h?1:i<h||c<g?-1:c>g?1:t.id<e.id?-1:t.id>e.id?1:0}constructor(t,e,n,r){this.id=++bt,this.leftSE=t,t.segment=this,t.otherSE=e,this.rightSE=e,e.segment=this,e.otherSE=t,this.rings=n,this.windings=r}static fromRing(t,e,n){let r,i,h;const o=M.comparePoints(t,e);if(o<0)r=t,i=e,h=1;else if(o>0)r=e,i=t,h=-1;else throw new Error(`Tried to create degenerate segment at [${t.x}, ${t.y}]`);const u=new M(r,!0),c=new M(i,!1);return new k(u,c,[n],[h])}replaceRightSE(t){this.rightSE=t,this.rightSE.segment=this,this.rightSE.otherSE=this.leftSE,this.leftSE.otherSE=this.rightSE}bbox(){const t=this.leftSE.point.y,e=this.rightSE.point.y;return{ll:{x:this.leftSE.point.x,y:t<e?t:e},ur:{x:this.rightSE.point.x,y:t>e?t:e}}}vector(){return{x:this.rightSE.point.x-this.leftSE.point.x,y:this.rightSE.point.y-this.leftSE.point.y}}isAnEndpoint(t){return t.x===this.leftSE.point.x&&t.y===this.leftSE.point.y||t.x===this.rightSE.point.x&&t.y===this.rightSE.point.y}comparePoint(t){if(this.isAnEndpoint(t))return 0;const e=this.leftSE.point,n=this.rightSE.point,r=this.vector();if(e.x===n.x)return t.x===e.x?0:t.x<e.x?1:-1;const i=(t.y-e.y)/r.y,h=e.x+i*r.x;if(t.x===h)return 0;const o=(t.x-e.x)/r.x,u=e.y+o*r.y;return t.y===u?0:t.y<u?-1:1}getIntersection(t){const e=this.bbox(),n=t.bbox(),r=X(e,n);if(r===null)return null;const i=this.leftSE.point,h=this.rightSE.point,o=t.leftSE.point,u=t.rightSE.point,c=G(e,o)&&this.comparePoint(o)===0,g=G(n,i)&&t.comparePoint(i)===0,s=G(e,u)&&this.comparePoint(u)===0,l=G(n,h)&&t.comparePoint(h)===0;if(g&&c)return l&&!s?h:!l&&s?u:null;if(g)return s&&i.x===u.x&&i.y===u.y?null:i;if(c)return l&&h.x===o.x&&h.y===o.y?null:o;if(l&&s)return null;if(l)return h;if(s)return u;const p=wt(i,this.vector(),o,t.vector());return p===null||!G(r,p)?null:T.round(p.x,p.y)}split(t){const e=[],n=t.events!==void 0,r=new M(t,!0),i=new M(t,!1),h=this.rightSE;this.replaceRightSE(i),e.push(i),e.push(r);const o=new k(r,h,this.rings.slice(),this.windings.slice());return M.comparePoints(o.leftSE.point,o.rightSE.point)>0&&o.swapEvents(),M.comparePoints(this.leftSE.point,this.rightSE.point)>0&&this.swapEvents(),n&&(r.checkForConsuming(),i.checkForConsuming()),e}swapEvents(){const t=this.rightSE;this.rightSE=this.leftSE,this.leftSE=t,this.leftSE.isLeft=!0,this.rightSE.isLeft=!1;for(let e=0,n=this.windings.length;e<n;e++)this.windings[e]*=-1}consume(t){let e=this,n=t;for(;e.consumedBy;)e=e.consumedBy;for(;n.consumedBy;)n=n.consumedBy;const r=k.compare(e,n);if(r!==0){if(r>0){const i=e;e=n,n=i}if(e.prev===n){const i=e;e=n,n=i}for(let i=0,h=n.rings.length;i<h;i++){const o=n.rings[i],u=n.windings[i],c=e.rings.indexOf(o);c===-1?(e.rings.push(o),e.windings.push(u)):e.windings[c]+=u}n.rings=null,n.windings=null,n.consumedBy=e,n.leftSE.consumedBy=e.leftSE,n.rightSE.consumedBy=e.rightSE}}prevInResult(){return this._prevInResult!==void 0?this._prevInResult:(this.prev?this.prev.isInResult()?this._prevInResult=this.prev:this._prevInResult=this.prev.prevInResult():this._prevInResult=null,this._prevInResult)}beforeState(){if(this._beforeState!==void 0)return this._beforeState;if(!this.prev)this._beforeState={rings:[],windings:[],multiPolys:[]};else{const t=this.prev.consumedBy||this.prev;this._beforeState=t.afterState()}return this._beforeState}afterState(){if(this._afterState!==void 0)return this._afterState;const t=this.beforeState();this._afterState={rings:t.rings.slice(0),windings:t.windings.slice(0),multiPolys:[]};const e=this._afterState.rings,n=this._afterState.windings,r=this._afterState.multiPolys;for(let o=0,u=this.rings.length;o<u;o++){const c=this.rings[o],g=this.windings[o],s=e.indexOf(c);s===-1?(e.push(c),n.push(g)):n[s]+=g}const i=[],h=[];for(let o=0,u=e.length;o<u;o++){if(n[o]===0)continue;const c=e[o],g=c.poly;if(h.indexOf(g)===-1)if(c.isExterior)i.push(g);else{h.indexOf(g)===-1&&h.push(g);const s=i.indexOf(c.poly);s!==-1&&i.splice(s,1)}}for(let o=0,u=i.length;o<u;o++){const c=i[o].multiPoly;r.indexOf(c)===-1&&r.push(c)}return this._afterState}isInResult(){if(this.consumedBy)return!1;if(this._isInResult!==void 0)return this._isInResult;const t=this.beforeState().multiPolys,e=this.afterState().multiPolys;switch(N.type){case"union":{const n=t.length===0,r=e.length===0;this._isInResult=n!==r;break}case"intersection":{let n,r;t.length<e.length?(n=t.length,r=e.length):(n=e.length,r=t.length),this._isInResult=r===N.numMultiPolys&&n<r;break}case"xor":{const n=Math.abs(t.length-e.length);this._isInResult=n%2===1;break}case"difference":{const n=r=>r.length===1&&r[0].isSubject;this._isInResult=n(t)!==n(e);break}default:throw new Error(`Unrecognized operation type found ${N.type}`)}return this._isInResult}}class nt{constructor(t,e,n){if(!Array.isArray(t)||t.length===0)throw new Error("Input geometry is not a valid Polygon or MultiPolygon");if(this.poly=e,this.isExterior=n,this.segments=[],typeof t[0][0]!="number"||typeof t[0][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");const r=T.round(t[0][0],t[0][1]);this.bbox={ll:{x:r.x,y:r.y},ur:{x:r.x,y:r.y}};let i=r;for(let h=1,o=t.length;h<o;h++){if(typeof t[h][0]!="number"||typeof t[h][1]!="number")throw new Error("Input geometry is not a valid Polygon or MultiPolygon");let u=T.round(t[h][0],t[h][1]);u.x===i.x&&u.y===i.y||(this.segments.push(k.fromRing(i,u,this)),u.x<this.bbox.ll.x&&(this.bbox.ll.x=u.x),u.y<this.bbox.ll.y&&(this.bbox.ll.y=u.y),u.x>this.bbox.ur.x&&(this.bbox.ur.x=u.x),u.y>this.bbox.ur.y&&(this.bbox.ur.y=u.y),i=u)}(r.x!==i.x||r.y!==i.y)&&this.segments.push(k.fromRing(i,r,this))}getSweepEvents(){const t=[];for(let e=0,n=this.segments.length;e<n;e++){const r=this.segments[e];t.push(r.leftSE),t.push(r.rightSE)}return t}}class vt{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");this.exteriorRing=new nt(t[0],this,!0),this.bbox={ll:{x:this.exteriorRing.bbox.ll.x,y:this.exteriorRing.bbox.ll.y},ur:{x:this.exteriorRing.bbox.ur.x,y:this.exteriorRing.bbox.ur.y}},this.interiorRings=[];for(let n=1,r=t.length;n<r;n++){const i=new nt(t[n],this,!1);i.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=i.bbox.ll.x),i.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=i.bbox.ll.y),i.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=i.bbox.ur.x),i.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=i.bbox.ur.y),this.interiorRings.push(i)}this.multiPoly=e}getSweepEvents(){const t=this.exteriorRing.getSweepEvents();for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getSweepEvents();for(let i=0,h=r.length;i<h;i++)t.push(r[i])}return t}}class it{constructor(t,e){if(!Array.isArray(t))throw new Error("Input geometry is not a valid Polygon or MultiPolygon");try{typeof t[0][0][0]=="number"&&(t=[t])}catch{}this.polys=[],this.bbox={ll:{x:Number.POSITIVE_INFINITY,y:Number.POSITIVE_INFINITY},ur:{x:Number.NEGATIVE_INFINITY,y:Number.NEGATIVE_INFINITY}};for(let n=0,r=t.length;n<r;n++){const i=new vt(t[n],this);i.bbox.ll.x<this.bbox.ll.x&&(this.bbox.ll.x=i.bbox.ll.x),i.bbox.ll.y<this.bbox.ll.y&&(this.bbox.ll.y=i.bbox.ll.y),i.bbox.ur.x>this.bbox.ur.x&&(this.bbox.ur.x=i.bbox.ur.x),i.bbox.ur.y>this.bbox.ur.y&&(this.bbox.ur.y=i.bbox.ur.y),this.polys.push(i)}this.isSubject=e}getSweepEvents(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getSweepEvents();for(let i=0,h=r.length;i<h;i++)t.push(r[i])}return t}}class U{static factory(t){const e=[];for(let n=0,r=t.length;n<r;n++){const i=t[n];if(!i.isInResult()||i.ringOut)continue;let h=null,o=i.leftSE,u=i.rightSE;const c=[o],g=o.point,s=[];for(;h=o,o=u,c.push(o),o.point!==g;)for(;;){const l=o.getAvailableLinkedEvents();if(l.length===0){const x=c[0].point,E=c[c.length-1].point;throw new Error(`Unable to complete output ring starting at [${x.x}, ${x.y}]. Last matching segment found ends at [${E.x}, ${E.y}].`)}if(l.length===1){u=l[0].otherSE;break}let p=null;for(let x=0,E=s.length;x<E;x++)if(s[x].point===o.point){p=x;break}if(p!==null){const x=s.splice(p)[0],E=c.splice(x.index);E.unshift(E[0].otherSE),e.push(new U(E.reverse()));continue}s.push({index:c.length,point:o.point});const y=o.getLeftmostComparator(h);u=l.sort(y)[0].otherSE;break}e.push(new U(c))}return e}constructor(t){this.events=t;for(let e=0,n=t.length;e<n;e++)t[e].segment.ringOut=this;this.poly=null}getGeom(){let t=this.events[0].point;const e=[t];for(let c=1,g=this.events.length-1;c<g;c++){const s=this.events[c].point,l=this.events[c+1].point;K(s,t,l)!==0&&(e.push(s),t=s)}if(e.length===1)return null;const n=e[0],r=e[1];K(n,t,r)===0&&e.shift(),e.push(e[0]);const i=this.isExteriorRing()?1:-1,h=this.isExteriorRing()?0:e.length-1,o=this.isExteriorRing()?e.length:-1,u=[];for(let c=h;c!=o;c+=i)u.push([e[c].x,e[c].y]);return u}isExteriorRing(){if(this._isExteriorRing===void 0){const t=this.enclosingRing();this._isExteriorRing=t?!t.isExteriorRing():!0}return this._isExteriorRing}enclosingRing(){return this._enclosingRing===void 0&&(this._enclosingRing=this._calcEnclosingRing()),this._enclosingRing}_calcEnclosingRing(){let t=this.events[0];for(let r=1,i=this.events.length;r<i;r++){const h=this.events[r];M.compare(t,h)>0&&(t=h)}let e=t.segment.prevInResult(),n=e?e.prevInResult():null;for(;;){if(!e)return null;if(!n)return e.ringOut;if(n.ringOut!==e.ringOut)return n.ringOut.enclosingRing()!==e.ringOut?e.ringOut:e.ringOut.enclosingRing();e=n.prevInResult(),n=e?e.prevInResult():null}}}class st{constructor(t){this.exteriorRing=t,t.poly=this,this.interiorRings=[]}addInterior(t){this.interiorRings.push(t),t.poly=this}getGeom(){const t=[this.exteriorRing.getGeom()];if(t[0]===null)return null;for(let e=0,n=this.interiorRings.length;e<n;e++){const r=this.interiorRings[e].getGeom();r!==null&&t.push(r)}return t}}class It{constructor(t){this.rings=t,this.polys=this._composePolys(t)}getGeom(){const t=[];for(let e=0,n=this.polys.length;e<n;e++){const r=this.polys[e].getGeom();r!==null&&t.push(r)}return t}_composePolys(t){const e=[];for(let n=0,r=t.length;n<r;n++){const i=t[n];if(!i.poly)if(i.isExteriorRing())e.push(new st(i));else{const h=i.enclosingRing();h.poly||e.push(new st(h)),h.poly.addInterior(i)}}return e}}class Rt{constructor(t){let e=arguments.length>1&&arguments[1]!==void 0?arguments[1]:k.compare;this.queue=t,this.tree=new D(e),this.segments=[]}process(t){const e=t.segment,n=[];if(t.consumedBy)return t.isLeft?this.queue.remove(t.otherSE):this.tree.remove(e),n;const r=t.isLeft?this.tree.add(e):this.tree.find(e);if(!r)throw new Error(`Unable to find segment #${e.id} [${e.leftSE.point.x}, ${e.leftSE.point.y}] -> [${e.rightSE.point.x}, ${e.rightSE.point.y}] in SweepLine tree.`);let i=r,h=r,o,u;for(;o===void 0;)i=this.tree.prev(i),i===null?o=null:i.key.consumedBy===void 0&&(o=i.key);for(;u===void 0;)h=this.tree.next(h),h===null?u=null:h.key.consumedBy===void 0&&(u=h.key);if(t.isLeft){let c=null;if(o){const s=o.getIntersection(e);if(s!==null&&(e.isAnEndpoint(s)||(c=s),!o.isAnEndpoint(s))){const l=this._splitSafely(o,s);for(let p=0,y=l.length;p<y;p++)n.push(l[p])}}let g=null;if(u){const s=u.getIntersection(e);if(s!==null&&(e.isAnEndpoint(s)||(g=s),!u.isAnEndpoint(s))){const l=this._splitSafely(u,s);for(let p=0,y=l.length;p<y;p++)n.push(l[p])}}if(c!==null||g!==null){let s=null;c===null?s=g:g===null?s=c:s=M.comparePoints(c,g)<=0?c:g,this.queue.remove(e.rightSE),n.push(e.rightSE);const l=e.split(s);for(let p=0,y=l.length;p<y;p++)n.push(l[p])}n.length>0?(this.tree.remove(e),n.push(t)):(this.segments.push(e),e.prev=o)}else{if(o&&u){const c=o.getIntersection(u);if(c!==null){if(!o.isAnEndpoint(c)){const g=this._splitSafely(o,c);for(let s=0,l=g.length;s<l;s++)n.push(g[s])}if(!u.isAnEndpoint(c)){const g=this._splitSafely(u,c);for(let s=0,l=g.length;s<l;s++)n.push(g[s])}}}this.tree.remove(e)}return n}_splitSafely(t,e){this.tree.remove(t);const n=t.rightSE;this.queue.remove(n);const r=t.split(e);return r.push(n),t.consumedBy===void 0&&this.tree.add(t),r}}const rt=typeof process<"u"&&{}.POLYGON_CLIPPING_MAX_QUEUE_SIZE||1e6,Pt=typeof process<"u"&&{}.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS||1e6;class Mt{run(t,e,n){N.type=t,T.reset();const r=[new it(e,!0)];for(let s=0,l=n.length;s<l;s++)r.push(new it(n[s],!1));if(N.numMultiPolys=r.length,N.type==="difference"){const s=r[0];let l=1;for(;l<r.length;)X(r[l].bbox,s.bbox)!==null?l++:r.splice(l,1)}if(N.type==="intersection")for(let s=0,l=r.length;s<l;s++){const p=r[s];for(let y=s+1,x=r.length;y<x;y++)if(X(p.bbox,r[y].bbox)===null)return[]}const i=new D(M.compare);for(let s=0,l=r.length;s<l;s++){const p=r[s].getSweepEvents();for(let y=0,x=p.length;y<x;y++)if(i.insert(p[y]),i.size>rt)throw new Error("Infinite loop when putting segment endpoints in a priority queue (queue size too big).")}const h=new Rt(i);let o=i.size,u=i.pop();for(;u;){const s=u.key;if(i.size===o){const p=s.segment;throw new Error(`Unable to pop() ${s.isLeft?"left":"right"} SweepEvent [${s.point.x}, ${s.point.y}] from segment #${p.id} [${p.leftSE.point.x}, ${p.leftSE.point.y}] -> [${p.rightSE.point.x}, ${p.rightSE.point.y}] from queue.`)}if(i.size>rt)throw new Error("Infinite loop when passing sweep line over endpoints (queue size too big).");if(h.segments.length>Pt)throw new Error("Infinite loop when passing sweep line over endpoints (too many sweep line segments).");const l=h.process(s);for(let p=0,y=l.length;p<y;p++){const x=l[p];x.consumedBy===void 0&&i.insert(x)}o=i.size,u=i.pop()}T.reset();const c=U.factory(h.segments);return new It(c).getGeom()}}const N=new Mt,At=function(f){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return N.run("union",f,e)},Lt=function(f){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return N.run("intersection",f,e)},Ot=function(f){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return N.run("xor",f,e)},_t=function(f){for(var t=arguments.length,e=new Array(t>1?t-1:0),n=1;n<t;n++)e[n-1]=arguments[n];return N.run("difference",f,e)};var Bt={union:At,intersection:Lt,xor:Ot,difference:_t};export{Bt as i};
