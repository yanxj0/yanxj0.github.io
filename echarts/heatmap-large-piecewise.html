<!--
	此示例下载自 https://echarts.apache.org/examples/zh/editor.html?c=heatmap-large-piecewise&random=ctk7vdgrt5&code=DYUwLgBAdg9glgZxBAvBA5uAcvJAJEYABxACcAKASgG4AoUSADwBEBDMV1CAbQF06GEAJ5sOXPnViIQAOiQgAJuQCy7ABYzSrKApgBbKjVoAzAK5QAxmDgwoGEFDLsQo1uTBrwrADQQ9cKF89VkZKCABvWggIQQV2TjQJKIhjGFIIckE4LgAGaghsgB40ACYcvIKAakqwyOjo1PTM8AgAK1z89uKIAEZyzura5PqIAHpRmJbGLnJg6YBaPwCwgCoCsYgynIhKpag6EejxycghGbmIRf8oVbaNvu3d64PDuI4ZIlMENXJuOF9Wr4pEgPmRgAESuRshMACw5AEbMphXY5GQAVl4RkOYwmb1YHy-Pz-AKBaWCwGYiDA7k8HF8oQga1gpHJlIQ1I8Xl8QkomJe0QAvsMICx4gTvlCsRAhQ00hlBO00BUur1-m1BhFhSIxZ8Ja0pTKIKRwKZSHY8XQhbF4lxMI4tGAXPFyCVfPM0b40UYYERrLYuHUIGAYDBgNYiAAuCIC7zJdCkOAKKOB6IJ9BqMBRnpw2MjUDGTMQOHJGPJRgAQUYiGTwrAQhIUYA5BZnOg0kJG7n6nio6KOCWu0JK9XNSM6w2IM3W-3O8Ke8JXAPkgA3RCmVjAVSR0f1ccgJtEOAgCwgADu0lnI2uUfhwrmWa70XzhcbaYzl93PqbJ6gjtIH-iFtgAsUxgFYAAjUAozAUhTBAR8jRADdrD0fcUg3JAEIQIhwTALBTD0cCyCjAAOBCAgAJW0TAa2xCxQzSKNuGFEZGwAYgAZh6DiADYAE40QAw52JhNEAHY0XAmEhNYtixJhVgFAUHoZPqdiIIUPiQD41TonYkAcmMDjjBI3TJzY4xLOMcDjDM9jjBAAy-JyOyLLiEAeJUhDZOMGEeIUGEONchQxI4nISjE1zWDRcoSh4xsWIgXhhUNUtoiQBMQAQJjhRTeooFYVCmwAcVYL4EDgbRVL3JtPHYYIiFU-c8W8iAQD0Ig1FYCrsp3bE4EdPQAGU6ygvrsQgcC0gUMgAGEGNIJtOI4oLWpGKbSBm0gAHVEw8LNEsFRK0sOIhSBgeMsoq5c0IeW9sW0OBgj9KAo2MDCQBS5JkoFOhxn-gHAaB4GQdBsHwbB2hjhIUhwTsYFkE8YgyBSc69AgDMwCIbLxnQAa1FMcCZHovRRlaGAkE69BRgR1oEChiHGaZ5mWYBkxzCsGw7EwPDcBAAhkYoIZALAhAEAgYqtAUcb6KgdlYKsNJyEYblfAAL2Fw4PEQGRpjQRh-V3NQdbONAhEN6JtYQGQ1a4NXDcNaJdDASEVeETWRmNMBTTsK3dcZEUdiDY3rbONZza-kZnY45XVYgDXxtTE0zWDnXpjWaZdj9sPhCDv3bbWe3I-lZJZfZDApY48RhUcU8Jal8gel8JuIBySgENr-vFPIeYW5btuO7PLulBb3vfAHmuh8l7ux8ufv28nuvp5H8fm4XkZO-Xnv-7Xwel4bne5_X_Kp4b2f4SPvfh_IC---P6JN4bi_Z56e_oFP7vb7dV-r635_R9ft9F4ZdIBEGriMHoaI-48VvhxMSvg-It2cs3D0vQuLNw4r4MoSDUF8R4p6TBvQ-IwiwStXw8DNglFQdme69ReLNxyIQsKvh-LNxhK6CAZEIB8T4r4OBWCcybD7hfEohCejIIgPg3oMIuElBhBQnoZQEKiJIRACSq9NhSPERQniHDiFYLRBwko4isGMObj0ChHFqEtw4hw8SzcxKWMwcKEisj-HSN4RANEUiSIKPkqY5uVCMFaLEtArhPEuEWNQf43oPFolN2FNxVR3FPEyKwQoniUjHFsK0WiNxLcSJiJ6C3EoJRPGKI4TArBxSMHOJGKIkRSjVS4I4TCFuaJUF-QEZ0kRMJknhTYYQtEqi4kGJYWIzyCESk9B8RfUKpjPFiS0bY5uvjTFcJIuUyJrDNjlGbngjB1DmGJJmasyJaJPEkS0Txfpt8cjlL4pE-ZvQrl8JYaowx1SKGlKkVQ2h0RFHJNEZ6UxHCOKRPkeYyJcUDGoJIhwkiqDjFGJyN8nIUiLlYIighSFsTPRPNWRwnomysFcPYVisRhSHEiO4uYzxcjzlGN8H0qZwzm48UIWJRpfc0RiJyDy6hPEKGBQcXowJ9KwX0t5fshBZFEk5EiX0ch5TaWUNUaIolYlImIvMUSnI6riUCKkXxb5JRZFQL4SQ4UciiV8UIaI2RSrpFAv2X3MS5TdECIKe0vuolSFIphOUq19SOLlNRcyh5Rjsx8L7iRPuPCGG5IUSRVRKbTHJKWeY6hxiEIxWZdm4VKCRFsrQW435ORcH2tKeYkZ3z6WqLEkYkViS2mBMiQJch4TfmQJYTyrRJEchAOSMcAAKjARCegYA3WDsgRwigUhygCDNaYp4tBEEPFAdAvhdCE1ADOiAMM9CmA4C9IMEE92gE3R4ZIghD1cE7uWUgWghDkCgSUKUgh4yKQAAr3qHo-59r7FFSlHSHAoCAoCNkgJwG6pAzhthgNLeQCgAjoBSBzF6vhwLHoKJAU8aQADW4sYAEZkBAAAkpABAph11pDAOLEoAA9GZw7cRwEsmQBwVHHLS2XBuOC1sIDbQTI6CACB9DgGNpuya4A_wFGMMIGAph37zsncaMTPHrbJDMJYU9yHyDIY9vJjIyGIAAD5W4QAAGRWY0_OwovQjNHAmENICyBOR2elkpsAiVTMrDQHE3lPEHbClM2gVQHgZDGGACGCghnDbsZMzxiADmqE8Sc55iAAAfNApnCgOZIiFkYjR5QtGyEqfIRRNjeMqxqPKT4WjLgtsZqE1nHOJ3qMuLgRA_i8AgIxpL87bNUK9M1gUbVgBIA69ELraAetwD6wN8gBnktmYsyRMIw2OlShGI7eoh7evdbIHoP4Qc0t9bQE1xKX6FDfsO2gG7d3si7HO7aSu3AusAFJeglH4MXQ0-m24vGOGxUHoOIDfrBAEaAfMxPe0stpjDXN0IzXcEZr2PsgwB0gGsHHGQ8fuADjxS4vQvRBz6AaRHunkegFIEQcgPhJq-DAOj5OdhG4k5ZwHTgWcA7gReIaY4JRmAQ6h3YHA0gqec39DDOGrtuRGeOAAMSXRAcwA0K6JggCeYAwBte2A4AEVDB74C_mFIIAAGlwCLGhouxeVm_aIABNa36gosxaVjyQ2xxiotGNGBaw07GBnHotNAIzhiMKaIKbvD-NoceHYNrwgwBhR60DosC3htTa50WE773ExhOsDAR5gIjpMDpB15NiAieRsmfJLTgov4QDl4PWQGw0sWx2CIo3mCiHTAnmlp4Y0lBhRW7QFbrbaJDYu7QC7yf-eICzQ3CBAPs7YeyxgnAbDL1xbGDRm1VgFg1AQBgApjzqRTT67NGQemeYWhQHKG9n93Are7AO073gvAZDO3l-7Q2ggH8egn9bsX8g539ydP9v8YAXZY4c9HN_978-hgC7tX9egwDjtuAP8v8f9lYScW4vdzdECgCHspYUDyd0CWRMCIDsDoDXY8DuQ8CdscRF99BPhRNz9FJkAQJSBp0-NgA4IF10hGBCDIBlM0B3pUdQgF9yMm86dQxnB90L90hjRqMwxb96gMcU5ad6dtDyAH8L4oAnVTB25Jg6c9D-UgQak1cTCJCQByAeRKck5vYU48pkMEJZcIQSxLRaBzwdAYBTxv8bQ0ALQfCl1_CZA9AhBZoupSBIA0BIjojWBYjqAgA
	⚠ 请注意，该图表不是 Apache ECharts 官方示例，而是由用户代码生成的。请注意鉴别其内容。
-->
<!DOCTYPE html>
<html lang="en" style="height: 100%">
  <head>
    <meta charset="utf-8" />
  </head>
  <body style="height: 100%; margin: 0">
    <div id="container" style="height: 100%"></div>

    <script
      type="text/javascript"
      src="https://registry.npmmirror.com/echarts/5.4.3/files/dist/echarts.min.js"
    ></script>

    <script type="text/javascript">
      var dom = document.getElementById("container");
      var myChart = echarts.init(dom, null, {
        renderer: "canvas",
        useDirtyRect: false,
      });
      var app = {};

      var option;

      let noise = getNoiseHelper();
      let xData = [];
      let yData = [];
      noise.seed(Math.random());
      function generateData(xLen, yLen) {
        let data = [];
        for (let i = 0; i < xLen; i++) {
          for (let j = 0; j < yLen; j++) {
            data.push([
              i,
              j,
              noise.perlin2(i / 40, j / 20) + Math.random(),
            ]);
          }
          xData.push(i);
        }
        for (let j = 0; j < yLen; j++) {
          yData.push(j);
        }
        return data;
      }
      let data = generateData(200, 100);
      option = {
        tooltip: {show:false},
        grid: {
          right: 140,
          left: 40,
        },
        xAxis: {
          type: "category",
          data: xData,
        },
        yAxis: {
          type: "category",
          data: yData,
          inverse: true,
        },
        visualMap: {
          type: "piecewise",
          min: 0,
          max: 1,
          left: "right",
          top: "center",
          calculable: true,
          realtime: false,
          splitNumber: 8,
          inRange: {
            color: [
              "#313695",
              "#4575b4",
              "#74add1",
              "#abd9e9",
              "#e0f3f8",
              "#ffffbf",
              "#fee090",
              "#fdae61",
              "#f46d43",
              "#d73027",
              "#a50026",
            ],
          },
        },
        series: [
          {
            name: "Gaussian",
            type: "heatmap",
            data: data,
            emphasis: {
              itemStyle: {
                borderColor: "#333",
                borderWidth: 1,
              },
            },
            zlevel: 2,
            progressive: 1000,
            animation: false,
          },
        ],
      };
      ///////////////////////////////////////////////////////////////////////////
      // perlin noise helper from https://github.com/josephg/noisejs
      ///////////////////////////////////////////////////////////////////////////
      function getNoiseHelper() {
        class Grad {
          constructor(x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
          }
          dot2(x, y) {
            return this.x * x + this.y * y;
          }
          dot3(x, y, z) {
            return this.x * x + this.y * y + this.z * z;
          }
        }
        const grad3 = [
          new Grad(1, 1, 0),
          new Grad(-1, 1, 0),
          new Grad(1, -1, 0),
          new Grad(-1, -1, 0),
          new Grad(1, 0, 1),
          new Grad(-1, 0, 1),
          new Grad(1, 0, -1),
          new Grad(-1, 0, -1),
          new Grad(0, 1, 1),
          new Grad(0, -1, 1),
          new Grad(0, 1, -1),
          new Grad(0, -1, -1),
        ];
        const p = [
          151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225,
          140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148,
          247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32,
          57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68,
          175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111,
          229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244,
          102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208,
          89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109,
          198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147,
          118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182,
          189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70,
          221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108,
          110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251,
          34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235,
          249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204,
          176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114,
          67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180,
        ];
        // To remove the need for index wrapping, double the permutation table length
        let perm = new Array(512);
        let gradP = new Array(512);
        // This isn't a very good seeding function, but it works ok. It supports 2^16
        // different seed values. Write something better if you need more seeds.
        function seed(seed) {
          if (seed > 0 && seed < 1) {
            // Scale the seed out
            seed *= 65536;
          }
          seed = Math.floor(seed);
          if (seed < 256) {
            seed |= seed << 8;
          }
          for (let i = 0; i < 256; i++) {
            let v;
            if (i & 1) {
              v = p[i] ^ (seed & 255);
            } else {
              v = p[i] ^ ((seed >> 8) & 255);
            }
            perm[i] = perm[i + 256] = v;
            gradP[i] = gradP[i + 256] = grad3[v % 12];
          }
        }
        seed(0);
        // ##### Perlin noise stuff
        function fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        }
        function lerp(a, b, t) {
          return (1 - t) * a + t * b;
        }
        // 2D Perlin Noise
        function perlin2(x, y) {
          // Find unit grid cell containing point
          let X = Math.floor(x),
            Y = Math.floor(y);
          // Get relative xy coordinates of point within that cell
          x = x - X;
          y = y - Y;
          // Wrap the integer cells at 255 (smaller integer period can be introduced here)
          X = X & 255;
          Y = Y & 255;
          // Calculate noise contributions from each of the four corners
          let n00 = gradP[X + perm[Y]].dot2(x, y);
          let n01 = gradP[X + perm[Y + 1]].dot2(x, y - 1);
          let n10 = gradP[X + 1 + perm[Y]].dot2(x - 1, y);
          let n11 = gradP[X + 1 + perm[Y + 1]].dot2(x - 1, y - 1);
          // Compute the fade curve value for x
          let u = fade(x);
          // Interpolate the four results
          return lerp(lerp(n00, n10, u), lerp(n01, n11, u), fade(y));
        }
        return {
          seed,
          perlin2,
        };
      }
      const loop = (layers) => {
        // 计算每个像素的大小
        const coordSys = myChart._chartsViews[0].__model.coordinateSystem;
        var xAxis = coordSys.getAxis("x");
        var yAxis = coordSys.getAxis("y");

        let pWidth = xAxis.getBandWidth() + 0.5;
        let pHeight = yAxis.getBandWidth() + 0.5;

        const ltP = myChart.convertToPixel({ seriesIndex: 0 }, [0, 0]);
        const rbP = myChart.convertToPixel({ seriesIndex: 0 }, [199, 99]);

        const insertP = myChart.convertToPixel({ seriesIndex: 0 }, [0, 1]);

        const width = rbP[0] - ltP[0] + pWidth;
        // const height = rbP[1] - ltP[1] + pHeight;
        const height = rbP[1] - ltP[1]; // 整体下移一行，舍去最后一行数据，故不加pHeight

        const imgData = getImgData(
          layers,
          width,
          height,
          ltP[0] - pWidth / 2,
          ltP[1] - pHeight / 2,
          pHeight
        );

        const data = generateData(200, 1);
        myChart.setOption({ series: [{ data }] });
        myChart._zr.painter._layers[layers.at(-1)].dom
          .getContext("2d")
          .putImageData(
            imgData,
            insertP[0] - pWidth / 2,
            insertP[1] - pHeight / 2
          );

        setTimeout(loop, 1000, [2, 2.001]);
      };

      const getImgData = (layers, width, height, offsetX, offsetY, pHeight) => {
        const canvas = document.createElement("canvas");
        canvas.height = height;
        canvas.width = width;
        const ctx = canvas.getContext("2d", { willReadFrequently: true });
        layers.forEach((it, i) => {
          const ctxTemp = myChart._zr.painter._layers[it].dom.getContext("2d");
          const da = ctxTemp.getImageData(
            offsetX,
            offsetY + pHeight * i,
            width,
            height - pHeight * i
          );
          ctx.putImageData(da, 0, pHeight * i);
        });

        return ctx.getImageData(0, 0, width, height);
      };

      setTimeout(loop, 1000, [2.001]);

      if (option && typeof option === "object") {
        myChart.setOption(option);
      }

      window.addEventListener("resize", myChart.resize);
    </script>
  </body>
</html>
